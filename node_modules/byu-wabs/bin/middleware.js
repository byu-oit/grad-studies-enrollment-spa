/**
 *  @license
 *    Copyright 2017 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
'use strict';
const authRequest   = require('./auth-request');
const brownie       = require('./brownie');
const byuOauth      = require('byu-wabs-oauth');
const cas           = require('@byu-oit/byu-cas');
const cheerio       = require('cheerio');
const Debug         = require('debug');
const fs            = require('fs');
const https         = require('https');
const path          = require('path');
const request       = require('request');
const schemas       = require('./schemas');
const util          = require('./util');
const wabsOptions   = require('./options');

const casUrl = 'https://cas.byu.edu';

module.exports = wabs;

function wabs(options) {
    const factory = {};

    // load wabs configuration
    console.log('Loading WABS configuration...');
    const config = wabsOptions.getSync(options);
    Object.freeze(config);
    console.log('WABS load completed');

    // get oauth instance promise
    const oauth = byuOauth(config.consumerKey, config.consumerSecret);

    Object.defineProperties(factory, {
        config: { value: config },
        debug: { value: Debug('wabs:' + config.appName) },
        oauth: { value: oauth }
    });

    factory.authenticated = middleware(factory, authenticated);
    factory.brownie = middleware(factory, brownies);
    factory.clientGrantProxy = middleware(factory, clientGrantProxy);
    factory.index = middleware(factory, index);
    factory.init = init;
    factory.login = middleware(factory, login);
    factory.logout = middleware(factory, logout);
    factory.sync = middleware(factory, sync);

    return factory;
}

function authenticated(options) {
    const config = schemas.authenticated.normalize(options || {});
    const rxExtension = /\.(.+)$/;
    return (req, res, next) => {
        const name = 'wabs-auth-' + util.base64EncodeData(req.baseUrl + req.path);
        res.clearCookie(name);

        const match = rxExtension.exec(req.path);
        const extension = match && match[1].toLowerCase();
        const redirectable = req.method === 'GET' && (!extension || extension === 'html' || extension === 'htm');

        // user authenticated so go to next middleware
        if (req.wabs.user) {
            next();

        // not authenticated and don't redirect to CAS
        } else if (!config.authenticate) {
            res.sendStatus(401);

        // not redirectable to CAS
        } else if (!redirectable) {
            this.debug('authenticated middleware will not redirect to CAS for ' + req.method + ' ' + req.originalUrl);
            res.sendStatus(401);

        // redirect to CAS for authentication
        } else if (req.cookies[name] !== req.originalUrl) {
            res.cookie(name, req.originalUrl, { maxAge: 300000 });
            redirectToCas(this, req, res, {
                gateway: false,
                redirect: req.originalUrl
            });

        // not authenticated or authentication failed
        } else {
            res.sendStatus(401);
        }
    }
}

function brownies() {
    return (req, res, next) => {
        if (req.method === 'POST') {
            this.debug('receiving brownie');
            receiveBrownie(this, req, res, next);
        } else {
            this.debug('not a POST method so no brownie');
            next();
        }
    }
}

function clientGrantProxy(option) {
    if (typeof option !== 'function' && typeof option !== 'string') {
        throw Error('Middleware clientGrantProxy expects a base URL string or a function as middleware.');
    }
    const getOptions = typeof option === 'function'
        ? option
        : req => {
            const options = {
                baseUrl: option,
                body: req.body || '',
                headers: req.headers,
                method: req.method,
                qs: Object.assign({}, req.query),
                url: req.path
            };
            if (typeof options.body === 'object') options.json = true;
            return options;
        };

    const proxy = async (context, req, res, config, allowRetry) => {
        const oauth = await context.oauth;
        const token = oauth.getClientGrantToken();
        config.headers.Authorization = 'Bearer ' + token.accessToken;
        let sendOk = false;

        request(config)
            .on('error', err => {
                context.debug('error proxying request: ' + err.message);
                res.sendStatus(500);
            })
            .on('data', function(data) {
                if (sendOk) res.write(data);
            })
            .on('end', function() {
                if (sendOk) res.end();
            })
            .on('response', function(response) {

                // response merits a token refresh and a retry
                if (allowRetry && responseIndicatesInvalidToken(response)) {
                    context.debug('proxied request has expired token, retrying');
                    return run(false);
                }

                // response does not need retry
                sendOk = true;
                res.status(response.statusCode);
                Object.keys(response.headers)
                    .forEach(key => {
                        res.set(key, response.headers[key]);
                    });
            });
    };

    return (req, res) => {
        const options = getOptions(req);
        this.debug('client grant proxy request: ' + req.method + ' ' + req.originalUrl);

        // prepare headers
        const headers = options.headers || {};
        if (options.headers) {
            Object.keys(options.headers).forEach(key => {
                const lowerCaseKey = key.toLowerCase();
                if (lowerCaseKey !== 'host' && lowerCaseKey !== 'referer') {
                    headers[lowerCaseKey] = options.headers[key];
                }
            });
        }
        options.headers = headers;

        proxy(this, req, res, options, true)
    }
}

function index(options) {
    const hasAuth = !!this.oauth;

    const config = schemas.index.normalize(options || {});
    if (config.sync && !hasAuth) throw Error('Cannot use WABS index middleware with sync because WSO2 credentials are missing.');

    const renderIsFunction = typeof config.render === 'function';
    const script = '<script src="' + this.config.reservedPath + '/script.js"></script>';
    const indexContent = renderIsFunction ? '' : injectScript(fs.readFileSync(config.render, 'utf8'));
    const sync = config.sync ? this.sync(config) : null;
    const render = renderIsFunction
        ? (req, res, next) => {
            config.render(req, function(err, content) {
                if (err) return next(err);
                res.set('content-type', 'text/html');
                res.send(injectScript(content));
            });
        }
        : (req, res) => {
            res.set('content-type', 'text/html');
            res.send(indexContent);
        };

    function injectScript(content) {
        const $ = cheerio.load(content);

        const scripts = $('script');
        if (scripts.length > 0) {
            const first = scripts.eq(0);
            if (first.parents('head').length === 0) {
                $('head').append(script);
            } else {
                first.before(script);
            }
        } else {
            $('head').append(script);
        }
        return $.html();
    }

    return (req, res, next) => {
        this.debug('running index');

        // if it has a file path extension then next middleware
        if (path.extname(req.path)) return next();

        // if not GET and brownies not supported the next middleware
        const method = req.method;
        if (!((method === 'POST' && config.brownie) || method === 'GET')) return next();

        // check all ignore options
        if (config.ignore) {
            const path = req.path.replace(/\/$/, '');
            const length = config.ignore;
            let i;
            for (i = 0; i < length; i++) {
                if (config.ignore[i](path)) return next();
            }
        }

        // receiving brownie
        if (req.method === 'POST' && config.brownie) {
            this.debug('index receiving brownie');
            receiveBrownie(this, req, res, next);

        } else if (req.method !== 'GET') {
            next();

        } else if (sync) {
            this.debug('index synchronizing auth');
            sync(req, res, err => {
                if (err) return next(err);
                this.debug('index rendering');
                render(req, res, next);
            });

        } else {
            this.debug('index rendering');
            render(req, res, next);
        }
    };
}

function init() {
    const config = this.config;
    const authCookieName = 'wabs-' + config.appName;
    const refreshCookieName = 'wabs-h-' + config.appName;
    const reservedPath = this.config.reservedPath;
    const rxFaviconUrl = /^(.*)?\/favicon.ico(\?.*)?$/;

    const env = process.env.HANDEL_ENVIRONMENT_NAME || process.env.NODE_ENV || 'dev';
    const context = this;

    let clientTokenPromise;
    function refreshClientToken () {
        clientTokenPromise = context.oauth
            .then(oauth => oauth.getClientGrantToken())
            .catch(err => {
                console.error(err.stack);
                process.exit(1);
            });
        return clientTokenPromise;
    }
    refreshClientToken();

    let script = fs.readFileSync(path.resolve(__dirname, '../www/wabs' + (env === 'dev' ? '': '.min') + '.js'), 'utf8');
    script = script.substr(0, script.lastIndexOf('('));
    script = script + '("' + this.config.appName + '", "' + this.config.reservedPath + '");';

    return (req, res, next) => {
        this.debug('running init');

        // check that cookies are working
        if (!req.cookies || !req.signedCookies) {
            return next(Error('Cookie-parser middleware must execute prior to WABS init middleware'));
        }

        // proxy favicon requests
        if (rxFaviconUrl.test(req.path)) {
            https
                .get('https://cdn.byu.edu/shared-icons/latest/favicons/favicon.ico', response => response.pipe(res))
                .on('error', err => {
                    console.error(err.stack);
                    res.sendStatus(500);
                });
            return;
        }

        // set up req.wabs object
        req.wabs = {
            auth: null,
            config: {
                appName: config.appName,
                casCallbackPath: config.casCallbackPath,
                host: config.host,
                openProxy: config.openProxy,
                reservedPath: config.reservedPath,
                wso2CallbackPath: config.wso2CallbackPath
            },
            refreshTokens: () => refreshTokens(this, req, res),
            request: async ({ body, method, headers, url }) => {
                const token = await clientTokenPromise;

                // make the request
                if (!headers) headers = {};
                headers.authorization = 'Bearer ' + token.accessToken;
                const res = await authRequest({
                    body: body || '',
                    method: method || 'GET',
                    headers: Object.assign({}, headers),
                    url: url
                });

                if (res.statusCode === 401 && String(res.body).indexOf('<ams:code>900901</ams:code>' !== -1)) {
                    const token = await refreshClientToken();
                    headers.authorization = 'Bearer ' + token.accessToken;
                    const res = await authRequest({
                        body: body || '',
                        method: method || 'GET',
                        headers: Object.assign({}, headers),
                        url: url
                    });
                }
            },
            state: util.decodeState(req.query.state),
            user: req.cookies['wabs'] ? JSON.parse(decodeURIComponent(req.cookies['wabs'])) : null
        };

        // get authenticated user
        const authCookieData = req.signedCookies[authCookieName];
        const refreshTokenCookieData = req.signedCookies[refreshCookieName];
        if (!authCookieData) {
            this.debug('user auth cookie not found');
        } else {
            this.debug('user auth cookie found');
            req.wabs.auth = JSON.parse(decodeURIComponent(authCookieData));
            req.wabs.auth.refreshToken = decodeURIComponent(refreshTokenCookieData);
        }

        // if the URL falls within the WABS reserved path then handle it
        if (req.originalUrl.indexOf(reservedPath) === 0) {
            const query = Object.assign({}, req.query);
            switch(req.originalUrl.substr(reservedPath.length).split('?')[0]) {
                case '/auto-close':
                    // close page if iFrame or popup
                    res.set('content-type', 'text/html');
                    res.send(`<html><body><script>
                        window.dispatchEvent(new Event('auto-close'));
                        try { window.close(); } catch (e) {}
                    </script></body></html>`);
                    break;

                case '/brownie-encode':
                    brownieEncode(req, res);
                    break;

                case '/login':
                    if (!query.success) return res.sendStatus(400);
                    redirectToCas(this, req, res, {
                        gateway: query.hasOwnProperty('gateway'),
                        success: query.success,
                        failure: query.failure || query.success
                    });
                    break;

                case '/logout':
                    if (!req.query.redirect) return res.sendStatus(400);
                    logoutRedirects(this, req, res, {
                        cas: query.hasOwnProperty('cas'),
                        cFramework: query.hasOwnProperty('cFramework'),
                        redirect: query.redirect,
                        wso2: query.hasOwnProperty('wso2')
                    });
                    break;

                // apparently this isn't being used because it's broken and there have been no PRs
                // case '/proxy':
                //     if (!config.openProxy) {
                //         res.status(403).send('Use of the client proxy function is currently disabled on the server.');
                //     } else {
                //         readBody(req)
                //             .then(body => {
                //                 const config = util.parseJson(body);
                //                 this.oauth.clientGrant.proxy(res, {
                //                     body: config.body || '',
                //                     method: config.method || 'GET',
                //                     headers: Object.assign({}, config.headers, req.headers),
                //                     url: config.url
                //                 });
                //             })
                //             .catch(next);
                //     }
                //     break;

                case '/refresh-tokens':
                    refreshTokens(this, req, res)
                        .then(() => res.sendStatus(200))
                        .catch(err => {
                            if (err.statusCode) {
                                if (err.safeMessage) return res.status(err.statusCode).send(err.message);
                                return res.sendStatus(err.statusCode);
                            }
                            console.error(err.stack);
                            return res.sendStatus(500);
                        });
                    break;

                case '/script.js':
                    res.set('content-type', 'text/javascript');
                    res.send(script);
                    break;

                default:
                    res.sendStatus(404);
                    break;
            }
            return;
        }

        // if no state then next middleware
        const state = req.wabs.state;
        if (!state || !state.action) return next();

        // if state then respond to action
        switch (state.action) {

            case 'cas-callback':
                casCallback(this, req, res);
                break;

            case 'wso2-callback':
                wso2Callback(this, req, res);
                break;

            default:
                res.status(400).send('Invalid WABS init action: ' + state.action);
        }

    }
}

function login(options) {
    const config = schemas.login.normalize(options || {});
    return (req, res) => {
        const query = Object.assign({}, req.query);
        const success = query.success || config.success;
        const failure = query.failure || config.failure || success;
        const gateway = query.hasOwnProperty('gateway')
            ? query.gateway === 'true'
            : config.gateway || false;

        // redirect to CAS
        redirectToCas(this, req, res, {
            gateway: gateway,
            success: success,
            failure: failure,
            query: config.query || {},
            wso2: config.wso2
        });
    };
}

function logout(options) {
    const config = schemas.logout.normalize(options || {});
    return (req, res) => {
        const options = Object.assign({}, config);
        if (req.query.redirect) options.redirect = req.query.redirect;
        logoutRedirects(this, req, res, options);
    };
}

function sync() {
    const name = 'wabs-sync-' + this.config.appName;
    return (req, res, next) => {

        // must be GET method
        if (req.method !== 'GET') {
            this.debug('Sync middleware only works with GET requests');
            next();
        }

        // sync has completed
        if (req.cookies[name]) {
            this.debug('sync completed');
            res.clearCookie(name);
            next();

        // redirect to CAS gateway to get latest authentication info
        } else {
            res.cookie(name, '1', { maxAge: 300000 });
            redirectToCas(this, req, res, {
                gateway: true,
                redirect: req.originalUrl
            });
        }
    };
}




function brownieEncode(req, res) {
    readBody(req)
        .then(body => {
            const value = typeof body === 'string' ? util.parseJson(body) : body;
            return value && brownie.encode(value);
        })
        .then(data => data ? res.send(data.__brownie) : res.sendStatus(400))
        .catch(err => {
            console.error(err.stack);
            res.sendStatus(500);
        });
}

function casCallback(context, req, res) {
    const config = context.config;
    const host = util.getHost(config, req);
    const state = req.wabs.state;
    const ticket = req.query.ticket;
    context.debug(ticket ? 'CAS sent ticket' : 'CAS did not send ticket');

    // if no ticket then not logged in
    if (!ticket) {
        const destination = state.failure || state.success || '/';
        const auth = req.wabs.auth;

        // if currently logged in then kill auth cookie, revoke wso2 tokens, log out of wso2
        if (auth) {
            logoutRedirects(context, req, res, {
                cas: false,
                cFramework: false,
                redirect: destination
            });

        } else {
            context.debug('redirect ' + destination);
            res.redirect(destination);
        }

    } else {

        // ask CAS directly if the ticket is valid
        let service = util.removeQueryParameter(host + req.originalUrl, 'ticket');
        cas.validate(ticket, service)
            .then(async response => {
                context.debug('CAS ticket valid for ' + response.username);
                const newState = util.encodeState({
                    action: 'wso2-callback',
                    failure: state.failure || state.success || '/',
                    success: state.success || '/',
                    sync: state.sync,
                    user: response.username
                });
                const callbackPath = host + config.wso2CallbackPath;
                context.debug('WSO2 callback path should be: ' + callbackPath);

                const oauth = await context.oauth;
                const url = await oauth.getAuthorizationUrl(callbackPath, newState);

                context.debug('redirect to WSO2 ' + url);
                res.redirect(url);
            })
            .catch(function error(e) {
                let destination = state.failure || state.success || '/';
                context.debug('Error: ' + e.stack);
                context.debug('redirect ' + destination);
                res.redirect(destination);
            });
    }
}

function logoutRedirects(context, req, res, config) {
    const user = req.wabs.user;
    const netId = user && user.netId;
    if (netId) context.debug('logout started for ' + netId);

    // revoke code grant tokens
    const auth = req.wabs.auth;
    let promise = Promise.resolve();
    if (auth) {
        const refreshToken = util.decrypt(context.config.encryptSecret, auth.refreshToken);
        promise = context.oauth
            .then(oauth => oauth.revokeToken(auth.accessToken, refreshToken))
            .then(
                () => context.debug('oauth code grant tokens revoked for ' + netId),
                err => context.debug('failed oauth code grant token revoke for ' + netId + ': ' + err.message)
            );
    }

    // clear the wabs cookie and the wabs app oauth cookie
    res.clearCookie('wabs');
    res.clearCookie('wabs-' + context.config.appName);
    res.clearCookie('wabs-h-' + context.config.appName);
    context.debug('cleared wabs cookies');

    // determine the redirects to perform
    const logOuts = [];
    if (config.wso2) logOuts.push({ url: 'https://api.byu.edu/logout', redirect: 'redirect_url' });
    if (config.cas) logOuts.push({ url: casUrl + '/cas/logout', redirect: 'service' });
    if (config.cFramework) logOuts.push({ url: 'https://y.byu.edu/logout', redirect: 'target' });
    context.debug('will logout from ' +
        (config.wso2 ? 'WSO2 ' : '') +
        (config.cas ? 'CAS ' : '') +
        (config.cFramework ? 'cFramework ' : ''));

    // add final redirect
    const length = logOuts.length;
    let destination = util.resolveUrl(util.getHost(context.config, req), config.redirect || '/');
    for (let i = 0; i < length; i++) destination = encodeURIComponent(destination);
    logOuts.push({ url: destination });

    // redirect to logout of WSO2, CAS, and then the C-Framework
    if (length) {
        const redirects = logOuts
            .map((logout, index) => {
                let result = logout.url;
                if (index < length) result += '?' + logout.redirect + '=';
                return result;
            });
        let redirectUrl = redirects.shift() + encodeURIComponent(redirects.join(''));
        promise.then(() => {
            context.debug('redirect ' + redirectUrl);
            res.redirect(redirectUrl);
        });

    // only logout locally
    } else {
        promise.then(() => {
            context.debug('redirect ' + destination);
            res.redirect(destination);
        });
    }
}

function middleware(context, middleware) {
    const name = middleware.name;
    return options => {
        const m = middleware.call(context, options);
        return (req, res, next) => {
            if (req.wabs) {
                m(req, res, next);
            } else {
                next(Error('Cannot use WABS ' + name + ' middleware prior to using WABS init middleware.'));
            }
        };
    };
}

function readBody(req) {
    if (req.body) return Promise.resolve(req.body);
    return new Promise((resolve, reject) => {
        let content = '';

        // begin reading incoming request body
        req.on('data', chunk => {
            content += chunk.toString();
        });

        // any error causes promise to reject
        req.on('error', reject);

        // once done reading then resolve
        req.on('end', () => {
            resolve(content);
        });
    });
}

// very basic form body parser for receiving brownies
function receiveBrownie(context, req, res, next) {
    readBody(req)
        .then(content => {
            const type = typeof content;
            if (type === 'object') return content;
            if (type !== 'string') return null;

            const result = {};
            content.split('&')
                .forEach(pair => {
                    const ar = pair.split('=');
                    result[ar[0]] = ar[1] ? decodeURIComponent(ar[1]) : ''
                });
            return result;
        })
        .then(data => data ? brownie.decode(data.brownie) : null)
        .then(brownie => {
            if (!brownie) {
                context.debug('received brownie not valid');
                context.debug('redirect ' + req.originalUrl);
                res.redirect(req.originalUrl)

            } else {
                context.debug('storing brownie in sessionStorage');
                const content = '<!doctype html><html lang="en"><head><meta charset="utf-8"><title>Loading...</title></head>' +
                    '<body><script>if (window.sessionStorage) ' +
                    'sessionStorage.setItem("wabs",JSON.stringify({encodeNeeded:false,store:' + JSON.stringify(brownie) + '}));' +
                    'window.location.replace("' + req.originalUrl + '");</script></body></html>';
                res.status(200);
                res.set('Content-Type', 'text/html');
                res.send(content);
            }
        })
        .catch(next);
}

function redirectToCas(context, req, res, options) {

    // set the cas service
    const service = util.addUrlState(util.getHost(context.config, req) + context.config.casCallbackPath, {
        action: 'cas-callback',
        wso2: options.hasOwnProperty('wso2') ? !!options.wso2 : true,
        success: options.success || options.redirect,
        failure: options.failure || options.redirect || options.success
    });

    // redirect to cas
    let redirectUrl = casUrl + '/cas/login?service=' + encodeURIComponent(service);
    if (options.gateway) redirectUrl += '&gateway=true';
    if (options.query) {
        Object.keys(options.query).forEach(key => {
            redirectUrl += '&' + key + '=' + encodeURIComponent(options.query[key]);
        });
    }
    context.debug('redirecting to CAS ' + (options.gateway ? 'gateway ' : '') + ': ' + redirectUrl);
    res.redirect(redirectUrl);
}

function refreshTokens(context, req, res) {
    return new Promise((resolve, reject) => {
        const auth = req.wabs.auth;
        const user = req.wabs.user;
        if (auth && user && auth.accessToken && auth.refreshToken) {
            const netId = user.netId;
            const secret = context.config.encryptSecret;

            context.debug('refreshing tokens for ' + netId);
            const refreshToken = util.decrypt(secret, auth.refreshToken);
            return context.oauth
                .then(oauth => oauth.refreshToken(refreshToken))
                .then(token => {
                    if (!token.accessToken) {
                        context.debug('tokens could not be refreshed for ' + netId);
                        const err = Error('Unable to refresh tokens');
                        err.statusCode = 401;
                        err.safeMessage = true;
                        reject(err);

                    } else {
                        // token.resourceOwner = { personId: user.personId };
                        context.debug('tokens refreshed for ' + netId);
                        updateAppOauthCookie(context, req, res, token);
                        resolve();
                    }
                })
                .catch(err => {
                    if (err.context && err.context.error_description) err.message = err.context.error_description;
                    context.debug('error refreshing tokens for ' + netId + ': ' + err.message);
                    err.statusCode = 500;
                    reject(err);
                });

        } else {
            context.debug('cannot refresh tokens when none exist');
            const err = Error('Cannot refresh access tokens when none exists');
            err.statusCode = 401;
            err.safeMessage = true;
            reject(err);
        }
    });
}

function updateAppOauthCookie(context, req, res, token) {
    const config = context.config;
    context.debug('set app oauth cookie ' + config.appName);

    const accessTokenExpiresDate = new Date(+token.expiresAt + 120000);   // add 2 minutes to expiration - access token valid up to 5 minutes after expiration
    const appCookieData = {
        accessToken: token.accessToken,
        expires: accessTokenExpiresDate.toISOString(),
        personId: token.resourceOwner.personId
    };
    res.cookie('wabs-' + config.appName, JSON.stringify(appCookieData), { signed: true });
    res.cookie('wabs-h-' + config.appName,
        encodeURIComponent(util.encrypt(context.config.encryptSecret, token.refreshToken)),
        { signed: true, httpOnly: true })
}

function wso2Callback(context, req, res) {
    const config = context.config;
    const host = util.getHost(config, req);
    const state = req.wabs.state;

    context.oauth
        .then(oauth => oauth.getAuthCodeGrantToken(req.query.code, host + config.wso2CallbackPath))
        .then(token => {
            if (!token || !token.resourceOwner) {
                context.debug('WSO2 authorization missing user data for ' + state.user);

            } else if (token.resourceOwner.netId !== state.user) {
                context.debug(`WSO2 user (${token.resourceOwner.netId}) does not match CAS user (${state.user})`);
                logout(req, res, {
                    cas: false,
                    cFramework: false,
                    redirect: state.failure || state.success || '/'
                });

            } else {
                context.debug('WSO2 and CAS users match');

                // update user session cookie
                const resourceOwner = token.resourceOwner;
                const userCookieData = {
                    byuId: resourceOwner.byuId,
                    netId: resourceOwner.netId,
                    personId: resourceOwner.personId,
                    preferredFirstName: resourceOwner.preferredFirstName,
                    prefix: resourceOwner.prefix,
                    restOfName: resourceOwner.restOfName,
                    sortName: resourceOwner.sortName,
                    suffix: resourceOwner.suffix,
                    surname: resourceOwner.surname,
                    surnamePosition: resourceOwner.surnamePosition
                };
                res.cookie('wabs', JSON.stringify(userCookieData));

                // update app oauth cookie
                updateAppOauthCookie(context, req, res, token);

                const destination = state.success || '/';
                context.debug('redirect ' + destination);
                res.redirect(destination);
            }
        })
        .catch(err => {
            const destination = state.failure || '/';
            const msg = {};
            Object.keys(err).forEach(key => msg[key] = err[key]);
            context.debug('authorization error: ' + err.stack + ' ' + JSON.stringify(msg));
            context.debug('redirect ' + destination);
            res.redirect(destination);
        });
}

function responseIndicatesInvalidToken(res) {
    return res.statusCode === 401
        && res.body.indexOf('<ams:code>900901</ams:code>') !== -1;
}
