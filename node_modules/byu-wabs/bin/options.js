/**
 *  @license
 *    Copyright 2017 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
'use strict';
const AWS                   = require('aws-sdk');
const fs                    = require('fs');
const oauth                 = require('byu-wabs-oauth');
const path                  = require('path');
const os                    = require('os');
const schemas               = require('./schemas');
const spawnSync             = require('child_process').spawnSync;
const requireMainFilename   = require('require-main-filename');

const main = module.parent ? requireMainFilename() : process.argv[2] || '';

/**
 * Get the middleware configuration options asynchronously.
 * @param {string|object} options
 * @returns {Promise.<object>}
 */
exports.get = function(options) {
    options = normalizeOptions(options);

    // validate that security data was not passed in
    if (options.consumerKey || options.consumerSecret || options.encryptSecret) {
        const message = 'To avoid security concerns the consumer key, consumer secret, and ' +
            'encrypt secret cannot be specified in code or injected directly into the ' +
            'middleware constructor function. Please see the README for instructions of where ' +
            'to put your configuration.';
        console.log(message);
        const err = Error(message);
        return Promise.reject(err);
    }

    return getFileConfig(options)
        .then(options => getAwsConfig(options))
        .then(options => schemas.config.normalize(options))
        .then(options => verifyWso2Credentials(options))
        .catch(err => {
            console.error(err.stack);
            throw err;
        });
};

/**
 * Get the middleware configuration options asynchronously.
 * @param {string|object} options
 * @returns {object}
 * @throws Error
 */
exports.getSync = function(options) {
    options = normalizeOptions(options);
    const child = spawnSync(process.argv[0], [ __filename, main, JSON.stringify(options) ]);

    const output = child.stdout.toString();
    const lines = output.split('\n').filter(v => v.length > 0);
    let config;

    lines.forEach(line => {
        try {
            config = JSON.parse(line);
        } catch (e) {
            console.log(line);
        }
    });


    if (config) return config;

    throw Error('Unable to load WABS configuration');
};

if (!module.parent) {
    let config;
    if (!process.argv[2]) {
        console.error('Missing required input argument: options');
        process.exit(1);
    } else {
        try {
            config = JSON.parse(process.argv[3]);
        } catch (e) {
            config = process.argv[3];
        }
    }

    exports.get(config)
        .then(opts => {
            console.log(JSON.stringify(opts));
            process.exit(0);
        })
        .catch(() => process.exit(1));
}


function parseJSON(json) {
    try {
        return JSON.parse(json);
    } catch (e) {}
}

function getAwsConfig(options) {
    return new Promise(resolve => {
        const ssm = new AWS.SSM(options.awsSsmConfig || { region: 'us-west-2' });
        let name = options.awsParameterName;

        // get default name if no name was provided
        if (!name) {
            if (!options.appName) {
                console.log('Cannot auto derive awsParameterName without appName');
                console.log('Skipping lookup of AWS Parameter Store configuration');
                return resolve(options);
            }
            name = options.appName + '.' +
                (process.env.HANDEL_ENVIRONMENT_NAME || process.NODE_ENV || 'dev') +
                '.WABS_CONFIG';
        }

        console.log('Checking AWS Parameter Store for configuration: ' + name);
        const params = {
            Name: name,
            WithDecryption: true
        };
        ssm.getParameter(params, function(err, param) {
            if (err) {
                console.log(err.message);
                return resolve(options);
            }

            const data = parseJSON(param.Parameter.Value);
            if (data === undefined) {
                console.log('AWS Parameter Store configuration data is not valid JSON');
                resolve(options);
            } else {
                console.log('Found AWS Parameter Store configuration');
                resolve(Object.assign({}, data, options));
            }
        });
    });
}

function getFileConfig(options) {
    return new Promise(resolve => {
        if (options.configFile) {
            const configFile = resolveConfigFile(options.configFile);
            console.log('Reading configuration file: ' + configFile);
            getProjectDirectory(path.dirname(main))
                .then(projectDirectory => {

                    // config file should not reside in the project directory
                    const relPath = path.relative(projectDirectory, configFile);
                    if (relPath.split(path.sep)[0] !== '..') {
                        console.log('Configuration file cannot reside within project directory');
                    } else {
                        fs.readFile(configFile, 'utf8', function(err, content) {
                            if (err) {
                                console.log('Configuration file read error: ' + err.message);
                                resolve(options);
                            } else {
                                const data = parseJSON(content);
                                if (data === undefined) {
                                    console.log('Configuration file data is not valid JSON');
                                    resolve(options);
                                } else {
                                    console.log('Found configuration file data');
                                    resolve(Object.assign({}, data, options));
                                }
                            }
                        });
                    }
                })
                .catch(err => {
                    console.error(err.stack);
                    resolve(options);
                });
        } else {
            console.log('Configuration file not specified');
            resolve(options);
        }
    });
}

function normalizeOptions(options) {
    if (typeof options === 'string') {
        const str = options;
        options = {};
        options[str.indexOf(path.sep) !== -1 ? 'configFile' : 'appName'] = str;
    }
    if (!options || typeof options !== 'object') throw Error('Invalid WABS middleware options specified');
    if (!options.appName) throw new Error('Missing required appName');
    return options;
}

function resolveConfigFile(filePath) {
  if (filePath.split(path.sep)[0] === '~') {
    // config file is in home directory, resolve using os.homedir()
    return filePath.replace(/^[~]/, os.homedir());
  }
  return filePath;
}

function getProjectDirectory(dirPath) {
    const parentDir = path.dirname(dirPath);
    if (parentDir === dirPath) return Promise.resolve(parentDir);
    return new Promise((resolve, reject) => {
        fs.stat(path.resolve(dirPath, 'package.json'), err => {
            if (err && err.code !== 'ENOENT') {
                reject(err);
            } else if (err) {
                getProjectDirectory(parentDir).then(resolve, reject);
            } else {
                resolve(dirPath);
            }
        })
    })
}

function verifyWso2Credentials(options) {
    return oauth(options.consumerKey, options.consumerSecret)
        .then(oauth => oauth.getClientGrantToken())
        .then(token => {
            if (!token || !token.accessToken) throw Error('Invalid WSO2 consumer key or consumer secret');
            return options;
        });
}
