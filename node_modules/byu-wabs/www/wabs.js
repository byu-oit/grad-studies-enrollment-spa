/**
 *  @license
 *    Copyright 2017 Brigham Young University
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 **/
(function(appName, reservedPath) {
    "use strict";

    var EVENT_PREFIX = 'byu-browser-oauth';

    var EVENT_STATE_CHANGE = EVENT_PREFIX + '-state-changed';
    var EVENT_LOGIN_REQUESTED = EVENT_PREFIX + '-login-requested';
    var EVENT_LOGOUT_REQUESTED = EVENT_PREFIX + '-logout-requested';
    var EVENT_REFRESH_REQUESTED = EVENT_PREFIX + '-refresh-requested';
    var EVENT_CURRENT_INFO_REQUESTED = EVENT_PREFIX + '-current-info-requested';

    var STATE_UNAUTHENTICATED = 'unauthenticated';
    var STATE_AUTHENTICATED = 'authenticated';
    var STATE_AUTHENTICATING = 'authenticating';
    var STATE_REFRESHING = 'refreshing';
    var STATE_ERROR = 'error';

    var isCFrameworkRx = /^https?:\/\/y(?:-[a-z]*)?\.byu.edu\/(?:[\s\S]*?)\.cgi[\/\?]?/i;
    var accessTokenTimeoutId;
    var authCookieName = 'wabs-' + appName;
    var prevAuthState = { oauth: false, user: false };
    var prevCookieString;
    var win = window;
    var doc = document;
    var session = win.sessionStorage;
    var originalBrownie;

    // don't allow this file to run twice on one page
    if (win.byu && win.byu.brownie) return;

    // define the BYU object
    var byu = win.byu || {};
    if (!byu.auth) byu.auth = {};
    if (!byu.brownie) byu.brownie = {};
    win.byu = byu;

    // CustomEvent polyfill
    (function() {
        if (typeof win.CustomEvent === "function") return false;

        function CustomEvent(event, params) {
            params = params || {bubbles: false, cancelable: false, detail: undefined};
            var evt = doc.createEvent('CustomEvent');
            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
            return evt;
        }

        CustomEvent.prototype = win.Event.prototype;
        win.CustomEvent = CustomEvent;
    })();

    function ajax(options, callback) {
        options = requestOptions(options);
        var xhr = new XMLHttpRequest();
        var promise = new Promise(function (resolve) {
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    var body = xhr.responseType === 'json' ? parseJson(xhr.responseText) : xhr.responseText;
                    resolve({
                        body: body,
                        status: xhr.status
                    });
                }
            };
            xhr.open(options.method, options.url);
            Object.keys(options.headers)
                .forEach(function(name) {
                    xhr.setRequestHeader(name, options.headers[name]);
                });
            xhr.send(options.hasOwnProperty('body') ? options.body : null);
        });
        if (!callback) return promise;
        promise
            .then(function(data) { callback(data.body, data.status) })
            .catch(function(err) { console.error(err.stack); })
        return xhr
    }

    function authPopup(url, name, options, callback) {
        if (!options) options = {};
        if (!options.width) options.width = 300;
        if (!options.height) options.height = 300;
        var popup = win.open( url, "wabs-popup-" + name + '-' + appName,
            "menubar=no,location=no,resizable=no,scrollbars=no,status=no,width=" + options.width + ",height=" + options.height);
        return popup.addEventListener('auto-close', function() {
            updateTimeouts();
            checkAuthChange(callback);
            try { popup.close(); } catch (e) {}
        });
    }

    function brownieEncodeNeeded() {
        return byu.brownie &&
            typeof byu.brownie === 'object' &&
            Object.keys(byu.brownie).length > 0 &&
            JSON.stringify(originalBrownie) !== JSON.stringify(byu.brownie);
    }

    function createFormInput(name, value) {
        var input = doc.createElement('input');
        input.setAttribute('name', name);
        input.setAttribute('value', value);
        return input;
    }

    function checkAuthChange(callback) {
        var user = byu.user;
        var personId = user && user.personId;
        var accessToken = byu.auth.accessToken;

        var userChanged = personId !== prevAuthState.user;
        var accessTokenChanged = accessToken !== prevAuthState.oauth;

        prevAuthState.oauth = accessToken;
        prevAuthState.user = personId;

        if (callback) callback(user, accessToken);
        if (userChanged) user ? dispatch('auth-login', user) : dispatch('auth-logout');
        if (accessTokenChanged) dispatch('access-token-update', accessToken);
    }

    function cookieProperty(key, transform) {
        var data = readCookie(authCookieName, true);
        if (!data) return;
        return transform ? transform(data[key]) : data[key];
    }

    function dispatch(name, data) {
        name = 'wabs-' + name;
        doc.dispatchEvent(new CustomEvent(name, { detail: data }));
        doc.dispatchEvent(new CustomEvent('wabs', { detail: { name: name, data: data }}));
    }

    function getBrowserOauthState(state) {
        var user = byu.user
        if (user) {
            var accessToken = byu.auth.accessToken
            return {
                state: state,
                token: {
                    bearer: accessToken,
                    authorizationHeader: 'Bearer ' + accessToken,
                    expiresAt: byu.auth.expires,
                    rawUserInfo: user
                },
                user: {
                    personId: user.personId,
                    byuId: user.byuId,
                    netId: user.netId,
                    name: {
                        sortName: user.sortName,
                        displayName: user.surnamePosition === 'F'
                            ? user.surname + ' ' + user.preferredFirstName
                            : user.preferredFirstName + ' ' + user.surname,
                        givenName: user.preferredFirstName,
                        familyName: user.surname,
                        familyNamePosition: user.surnamePosition
                    },
                    rawUserInfo: user
                }
            }
        } else {
            return {
                state: state
            }
        }
    }

    function parseJson(str) {
        try {
            return JSON.parse(str);
        } catch (e) {
            return null;
        }
    }

    function readCookie(name, signed) {
        var cookieArray = doc.cookie.split(/; */);
        var length = cookieArray.length;
        var value = null;
        var i, cookie;
        name += '=';
        for(i = 0; i < length; i++) {
            cookie = cookieArray[i];
            if (cookie.indexOf(name) === 0) {
                value = decodeURIComponent(cookie.substring(name.length, cookie.length));
                if (signed) value = value.substring(2, value.lastIndexOf('.'));
                value = parseJson(value);
            }
        }
        return value;
    }

    function requestOptions(options) {
        var config = typeof options === 'string' ? { url: options } : Object.assign({}, options);

        if (typeof config.url !== 'string') throw Error('Missing required property: url');
        if (!config.method) config.method = 'GET';
        config.method = config.method.toUpperCase();

        // put all header names to lower case
        var headers = {};
        if (!config.headers) config.headers = {};
        Object.keys(config.headers)
            .forEach(function(name) {
                headers[name.toLowerCase()] = config.headers[name];
            });
        config.headers = headers;

        // if the body is an object then stringify and add
        if (config.body && typeof config.body === 'object') {
            if (!config.headers['content-type']) config.headers['content-type'] = 'application/json';
            config.body = JSON.stringify(config.body);
        }

        return config;
    }

    function storageUpdate() {
        var user = byu.user;
        var data = {
            __brownie: originalBrownie && originalBrownie.__brownie,
            brownie: byu.brownie,
            encodeNeeded: brownieEncodeNeeded(),
            personId: user ? user.personId : ''
        };
        session.setItem('wabs', JSON.stringify(data));
    }

    function toDate(value) {
        return new Date(value);
    }

    function updateTimeouts() {
        clearTimeout(accessTokenTimeoutId);
        var expires = cookieProperty('expires', toDate);
        if (expires) accessTokenTimeoutId = setTimeout(byu.auth.refreshToken, +expires - Date.now());
    }



    if (!byu.ajax) byu.ajax = ajax;

    Object.defineProperties(byu, {

        /**
         * Get the user object if logged in.
         * @name byu.user
         * @type {Object, undefined}
         * @readonly
         */
        user: { get: function() { return readCookie('wabs') } }
    });

    Object.defineProperties(byu.auth, {

        /**
         * Get the user access token.
         * @name byu.auth.accessToken
         * @type {string, undefined}
         * @readonly
         */
        accessToken: { get: function() { return cookieProperty('accessToken'); } },

        /**
         * Get a Date object of when the wabs cookie expires.
         * @name byu.auth.expires
         * @type {Date}
         */
        expires: { get: function() { return cookieProperty('expires', toDate); } }
    });

    /**
     * Initialize login.
     * @param {string} [success] The URL to direct to on success
     * @param {string|object} [options] If a string, the URL to direct to on failure.
     * @param {string} [options.failure] The URL to direct to on failure.
     * @param {boolean} [options.popup=false] Set to true to use a popup window to log in.
     */
    byu.auth.login = function(success, options) {
        if (!options) options = {};
        if (typeof success === 'object') options = success;
        if (options.popup) {
            options.failure = reservedPath + '/auto-close';
            options.success = reservedPath + '/auto-close';
        }
        if (!options.success) options.success = win.location.href;
        if (!options.failure) options.failure = options.success;
        dispatch(EVENT_STATE_CHANGE, getBrowserOauthState(STATE_AUTHENTICATING))
        var location = reservedPath + '/login?success=' + encodeURIComponent(options.success) +
            '&failure=' + encodeURIComponent(options.failure);
        if (options.popup) {
            authPopup(location, 'login', { width: 800, height: 700 });
        } else {
            win.location = location;
        }
    };

    /**
     * Initialize logout
     * @param {string|boolean} [redirect]
     * @param {object} [options]
     * @param {boolean} [options.cas=true]
     * @param {boolean} [options.cFramework=true]
     * @param {boolean} [options.wso2=true]
     * @param {boolean} [options.popup=false]
     */
    byu.auth.logout = function(redirect, options) {
        var a = arguments;
        var qs = '';
        if (typeof a[0] === 'object') {
            options = a[0];
            redirect = '';
        }
        if (!redirect) redirect = win.location.href;
        var location = reservedPath + '/logout';
        if (!options) options = {};
        ['cas', 'cFramework', 'wso2'].forEach(function(key) {
            if ((!options.popup || key !== 'cFramework') && (!options || options[key] !== false)) qs += '&' + key;
        });
        if (options.popup) {
            authPopup(location + '?redirect=' + encodeURIComponent(reservedPath + '/auto-close') + qs, 'logout');
        } else {
            win.location = location + '?redirect=' + encodeURIComponent(redirect) + qs;
        }
    };

    /**
     * Make an AJAX request to the WABS proxy interface.
     * @param {object|string} options
     * @param {string} options.url
     * @param {string} [options.method='GET']
     * @param {Object.<string,string>} [options.headers={}]
     * @param {object|string} [options.body]
     * @param {function} [callback]
     */
    byu.auth.proxy = function(options, callback) {
        return ajax({
            method: 'POST',
            url: reservedPath + '/proxy',
            body: requestOptions(options)
        }, callback);
    };

    /**
     * Function to refresh oauth tokens.
     * @param {Function} [callback]
     */
    byu.auth.refreshToken = function(callback) {
        dispatch(EVENT_STATE_CHANGE, getBrowserOauthState(STATE_REFRESHING))
        var promise = ajax(reservedPath + '/refresh-tokens')
            .then(function(data) {
                var body = data.body;
                var status = data.status;
                if (status >= 400) {
                    dispatch(EVENT_STATE_CHANGE, { state: STATE_ERROR, error: Error(body) })
                } else {
                    dispatch(EVENT_STATE_CHANGE, getBrowserOauthState(STATE_AUTHENTICATED))
                }
                return data;
            });
        if (!callback) return promise;
        promise
            .then(function(data) { callback(data.body, data.status) })
            .catch(function(err) { console.error(err.stack) })
    };

    // /**
    //  * Make an AJAX request. Automatically add the bearer token to the authorization header. If response
    //  * indicates invalid token then refresh token and try once more.
    //  * @param {object|string} options
    //  * @param {string} options.url
    //  * @param {string} [options.method='GET']
    //  * @param {Object.<string,string>} [options.headers={}]
    //  * @param {object|string} [options.body]
    //  * @param {function} callback
    //  */
    // byu.auth.request = function(options, callback) {
    //     var accessToken = byu.auth.accessToken;
    //     if (!accessToken) throw Error('User must be authenticated to make a request.');
    //
    //     options = Object.assign({}, options);
    //     if (!options.headers) options.headers = {};
    //     options.headers.authorization = 'Bearer ' + accessToken;
    //
    //     var promise = ajax(options)
    //         .then(function(data) {
    //             var body = data.body;
    //             var code = data.status;
    //             if (code === 401 && typeof body === 'string' && body.indexOf('<ams:code>900901</ams:code>') !== -1) {
    //                 return byu.auth.refreshToken()
    //                     .then(function () {
    //                         var accessToken = byu.auth.accessToken;
    //                         if (!accessToken) return callback(body, code);
    //                         options.headers.authorization = 'Bearer ' + accessToken;
    //                         return ajax(options);
    //                     });
    //             } else {
    //                 return data;
    //             }
    //         });
    //     if (!callback) return promise;
    //     promise.then(function (data) { callback(data.body, data.status) })
    //         .catch(function (err) { console.error(err.stack); })
    // };



    /**
     * Make an AJAX request. Automatically add the bearer token to the authorization header. If response
     * indicates invalid token then refresh token and try once more.
     * @param {object|string} options
     * @param {string} options.url
     * @param {string} [options.method='GET']
     * @param {Object.<string,string>} [options.headers={}]
     * @param {object|string} [options.body]
     * @param {function} callback
     */
    byu.auth.request = function(options, callback) {

        let retries = 0

        function sleep(ms)
        {
            return new Promise(resolve => setTimeout(resolve, ms))
        }

        function checkRetry(data, options) {
            const body = data.body
            const code = data.status
            if (retries > 2)
            {
                return data
            }
            retries += 1;
            if (code === 401 && typeof body === 'string' && body.indexOf('<ams:code>900901</ams:code>') !== -1) {
                return byu.auth.refreshToken()
                    .then(function () {
                        var accessToken = byu.auth.accessToken;
                        if (!accessToken) return callback(body, code);
                        options.headers.authorization = 'Bearer ' + accessToken;
                        return ajax(options)
                            .then(function(data) {
                                return checkRetry(data, options)
                            })
                    });
            } else if (code > 500) {
                return sleep(200).then(val =>{
                    return ajax(options)
                        .then(function(data) {
                            return checkRetry(data, options)
                        })
                })
            }
            else {
                return data;
            }
        }

        var accessToken = byu.auth.accessToken;
        // if (!accessToken) throw Error('User must be authenticated to make a request.');

        options = Object.assign({}, options);
        if (!options.headers) options.headers = {};
        if (accessToken) {
            options.headers.authorization = 'Bearer ' + accessToken;
        }

        var promise = ajax(options)
            .then(function(data) {
                return checkRetry(data, options)
            });
        if (!callback) return promise;
        promise.then(function (data) { callback(data.body, data.status) })
            .catch(function (err) {
                console.error(err.stack);
                callback(null, 500)
            })
    };

    /**
     * Make an authentication and authorization synchronization request. This will cause a temporary popup window to appear.
     * @param {function} [callback]
     */
    byu.auth.sync = function(callback) {
        var url = reservedPath + '/login?success=' + encodeURIComponent(reservedPath + '/auto-close') +
            '&failure=' + encodeURIComponent(reservedPath + '/logout?cas&wso2&redirect=' + reservedPath + '/auto-close') +
            '&gateway=true';
        authPopup(url, 'sync', {}, callback);
    };

    /**
     * Navigate to a specified URL while maintaining brownie data.
     * @param {string} url The Url to navigate to.
     * @param {string} [target="_self"] The target window to cause to navigate.
     * @param {function} [callback] A function to call immediately before navigating.
     */
    byu.navigateTo = function(url, target, callback) {
        var a = arguments;
        if (!target) target = '_self';
        if (typeof a[1] === 'function') {
            callback = a[1];
            target = '_self';
        }
        if (typeof callback !== 'function') callback = function() {};

        // create a form to submit
        var form = doc.createElement('form');
        form.setAttribute('method', 'POST');
        form.style.display = 'none';
        form.setAttribute('target', target);
        form.setAttribute('action', url);
        doc.body.appendChild(form);

        // if no brownie data then submit an empty form
        if (!byu.brownie || typeof byu.brownie !== 'object' && Object.keys(byu.brownie).length === 0) return submit();

        // add form inputs - going to submit brownie
        var input = createFormInput('brownie', originalBrownie ? originalBrownie.__brownie || '' : '');
        form.appendChild(input);
        form.appendChild(createFormInput('__notCFramework', 'true'));

        // if no encode needed then send existing brownie data
        if (!brownieEncodeNeeded()) return submit();

        // display loader UI because AJAX request in progress
        var loader = doc.createElement('div');
        loader.style.cssText = 'display: block; position: fixed; top: 0; bottom: 0; left: 0; right: 0; background-color: #FFF; opacity: 0; cursor: wait; transition: opacity 300ms';
        doc.body.appendChild(loader);
        setTimeout(function() { loader.style.opacity = '.5'; });

        // encode the brownie and post it
        byu.ajax({ method: 'POST', url: reservedPath + '/brownie-encode', body: byu.brownie }, function(body, code) {
            loader.style.opacity = '1';
            setTimeout(function() { doc.body.removeChild(loader); }, 300);
            if (code === 200) {
                input.value = body;
                submit();
            } else {
                callback(Error('Unexpected response: [' + code + '] ' + body));
            }
        });

        function submit() {
            callback(null);
            form.submit();
        }
    };




    // initialize the brownie and prev auth state
    (function() {
        var data = parseJson(session.getItem('wabs'));
        if (data && data.store) {
            var user = byu.user;
            var brownie = data.store;
            var currentPersonId = user ? user.personId : '';
            byu.brownie = brownie.personId && currentPersonId !== brownie.personId ? {} : brownie;
            originalBrownie = Object.assign({}, byu.brownie);
            storageUpdate();
        }

        prevAuthState.user = !!byu.user;
        prevAuthState.auth = byu.auth.accessToken;
    })();

    // handle link clicks that navigate to C-Framework
    doc.addEventListener('click', function (e) {
        var el = e.target || e.srcElement;
        if (el && el.tagName === 'A') {
            var href = el.getAttribute('href');
            var target = el.getAttribute('target') || '_self';
            if (isCFrameworkRx.test(href) || target !== '_self') {
                e.preventDefault();
                byu.navigateTo(href, target);
            }
        }
    });

    doc.addEventListener(EVENT_LOGIN_REQUESTED, function() { byu.auth.login() })
    doc.addEventListener(EVENT_LOGOUT_REQUESTED, function () { return byu.auth.logout(); })
    doc.addEventListener(EVENT_REFRESH_REQUESTED, function () { return byu.auth.refreshToken(); })
    doc.addEventListener(EVENT_CURRENT_INFO_REQUESTED, function (e) {
        e.detail.callback(getBrowserOauthState(byu.user ? STATE_AUTHENTICATED : STATE_UNAUTHENTICATED))
    })

    // update session storage before navigating away
    win.addEventListener("beforeunload", storageUpdate);

    // add timeouts that fire events for user auth changes
    updateTimeouts();

    // auto sync if other wabs app logs in or out
    setInterval(function () {
        // shortcut the function if cookie is unchanged
        if (doc.cookie === prevCookieString) return;
        prevCookieString = doc.cookie;

        checkAuthChange();

        // get user and oauth state
        var user = byu.user;
        var oauth = readCookie(authCookieName, true);

        // perform sync
        if ((!user && oauth) || (user && !oauth) || (oauth && oauth.personId !== user.personId)) byu.auth.sync();
    }, 1000);

})(appName, reservedPath);